<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>BioShooter — Bioinformatics Quiz Shooter</title>
<style>
  :root {
    --bg: #0b1221;
    --ink: #e6edf3;
    --accent: #48c1c9;
    --accent2: #8a5cf6;
    --good: #21d07a;
    --bad: #ff6b6b;
    --panel: #121a2f;
    --muted: #91a0b6;
  }
  html, body {
    margin: 0; height: 100%; background: var(--bg); color: var(--ink);
    font-family: ui-sans-serif, system-ui, "Segoe UI", Roboto, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji";
    overflow: hidden;
  }
  #ui {
    position: fixed; inset: 0; pointer-events: none;
  }
  .topbar {
    position: absolute; top: 10px; left: 50%; transform: translateX(-50%);
    display: flex; gap: 16px; align-items: center; background: rgba(18,26,47,0.7);
    border: 1px solid rgba(255,255,255,0.08); padding: 8px 14px; border-radius: 10px;
    backdrop-filter: blur(6px);
  }
  .pill { padding: 4px 10px; border-radius: 999px; font-weight: 600; background: rgba(255,255,255,0.06); }
  .pill.good { color: var(--good); }
  .pill.bad { color: var(--bad); }
  .question {
    position: absolute; top: 60px; left: 50%; transform: translateX(-50%);
    max-width: min(900px, 92vw);
    background: rgba(18,26,47,0.7); border: 1px solid rgba(255,255,255,0.08);
    padding: 12px 16px; border-radius: 12px; backdrop-filter: blur(6px); line-height: 1.35;
    font-size: clamp(16px, 1.8vw, 20px);
  }
  .timerbar {
    height: 8px; background: rgba(255,255,255,0.08); border-radius: 999px; overflow: hidden;
    margin-top: 8px;
  }
  .timerbar > div {
    height: 100%; width: 0%; background: linear-gradient(90deg, var(--good), #f1c40f, var(--bad));
    transition: width 0.2s linear;
  }
  .center {
    position: absolute; inset: 0; display: grid; place-items: center; pointer-events: none;
  }
  .card {
    pointer-events: auto; text-align: center; max-width: min(720px, 92vw);
    background: var(--panel); border: 1px solid rgba(255,255,255,0.08);
    padding: 18px 20px; border-radius: 14px; box-shadow: 0 10px 30px rgba(0,0,0,0.4);
  }
  .title { font-size: clamp(24px, 3.5vw, 36px); margin-bottom: 8px; }
  .subtitle { color: var(--muted); margin-bottom: 16px; }
  .btnrow { display: flex; gap: 12px; justify-content: center; flex-wrap: wrap; }
  button {
    pointer-events: auto; background: linear-gradient(180deg, var(--accent), var(--accent2));
    border: none; color: white; padding: 10px 16px; border-radius: 10px; font-weight: 700; cursor: pointer;
  }
  button.secondary {
    background: transparent; border: 1px solid rgba(255,255,255,0.18); color: var(--ink);
  }
  canvas { display: block; width: 100vw; height: 100vh; }
  .toast {
    position: absolute; bottom: 18px; left: 50%; transform: translateX(-50%);
    background: rgba(18,26,47,0.8); border: 1px solid rgba(255,255,255,0.08);
    padding: 8px 12px; border-radius: 10px; color: var(--muted); font-size: 14px;
  }
  .explain {
    position: absolute; top: 110px; left: 50%; transform: translateX(-50%);
    background: rgba(18,26,47,0.8); border: 1px solid rgba(255,255,255,0.08);
    padding: 8px 12px; border-radius: 10px; color: var(--ink); font-weight: 600;
  }
  ul { margin: 0; padding-left: 18px; }
</style>
</head>
<body>
<canvas id="game"></canvas>

<div id="ui">
  <div class="topbar" id="topbar" style="display:none">
    <div class="pill" id="levelpill">Level 1</div>
    <div class="pill">Q <span id="qindex">1</span>/<span id="qtotal">10</span></div>
    <div class="pill good">Score: <span id="score">0</span></div>
    <div class="pill bad">Wrong: <span id="wrong">0</span></div>
  </div>

  <div class="question" id="qbox" style="display:none">
    <div id="qtext">Question goes here</div>
    <div class="timerbar"><div id="timefill"></div></div>
  </div>

  <div class="center" id="startscreen">
    <div class="card">
      <div class="title">BioShooter</div>
      <div class="subtitle">Shoot the right bioinformatics answer before time runs out. Aim with your mouse. Click or press Space to fire.</div>
      <div class="btnrow">
        <button id="startbtn">Start Game</button>
        <button class="secondary" id="howbtn">How to play</button>
      </div>
    </div>
  </div>

  <div class="center" id="howpanel" style="display:none;">
    <div class="card">
      <div class="title">How it works</div>
      <ul style="text-align:left; line-height:1.5; margin-bottom:14px;">
        <li>Move mouse to aim the turret; click or press Space to shoot.</li>
        <li>Click or press Space Carefully, or you will miss the next question.</li>
        <li>Answers drift and bounce. Hit the correct one to advance.</li>
        <li>Wrong hits deduct time. Don’t spray and pray.</li>
        <li>Levels get harder:
          <ul>
            <li>Level 1: direct recall, 60s/question.</li>
            <li>Level 2: core concepts, 45s/question.</li>
            <li>Level 3: problem solving, 30s/question.</li>
          </ul>
        </li>
      </ul>
      <div class="btnrow">
        <button id="howclose">Back</button>
      </div>
    </div>
  </div>

  <div class="center" id="gameover" style="display:none;">
    <div class="card">
      <div class="title" id="ovtitle">Great run!</div>
      <div class="subtitle" id="ovstats">You scored 0.</div>
      <div class="btnrow">
        <button id="restart">Play Again</button>
      </div>
    </div>
  </div>

  <div class="toast" id="toast" style="display:none;"></div>
  <div class="explain" id="explain" style="display:none;"></div>
</div>

<script>
(() => {
  // ---------- Question banks (original + many new problem-solving items) ----------
  const EASY = [
    { q: "How many nucleotides are in a codon?", options: ["2", "3", "4", "6"], correct: 1, exp: "Codons are triplets of nucleotides." },
    { q: "Which base pairs with Adenine (A) in DNA?", options: ["Uracil (U)", "Cytosine (C)", "Thymine (T)", "Guanine (G)"], correct: 2, exp: "In DNA, A pairs with T (A–T), C pairs with G (C–G)." },
    { q: "What does FASTA primarily store?", options: ["Protein structures", "Sequences with headers", "Read quality scores", "Genome annotations"], correct: 1, exp: "FASTA stores sequences with '>' headers and sequence lines." },
    { q: "BLAST is used for…", options: ["Genome assembly", "Sequence similarity search", "Variant calling", "Gene expression quantification"], correct: 1, exp: "BLAST finds local regions of similarity." },
    { q: "Enzyme most associated with PCR?", options: ["Ligase", "Taq polymerase", "RNase H", "Topoisomerase"], correct: 1, exp: "Thermostable Taq polymerase amplifies DNA in PCR." },
    { q: "Central dogma flow:", options: ["RNA → DNA → Protein", "DNA → RNA → Protein", "Protein → RNA → DNA", "DNA → Protein → RNA"], correct: 1, exp: "Genetic info flows DNA → RNA → Protein." },
    { q: "Which is NOT a DNA stop codon?", options: ["TAA", "TAG", "TGA", "TTT"], correct: 3, exp: "Stop codons are TAA, TAG, TGA. TTT codes for Phe." },
  ];

  const MED = [
    { q: "GC content of ATGCGC?", options: ["33.3%", "50.0%", "66.7%", "83.3%"], correct: 2, exp: "4/6 bases are G or C → 66.7%." },
    { q: "Reverse complement of ATGC?", options: ["ATGC", "GCAT", "TACG", "CGTA"], correct: 1, exp: "Complement: TACG; reverse: GCAT." },
    { q: "Start codon in DNA is typically…", options: ["ATG", "TAA", "TAG", "TGA"], correct: 0, exp: "ATG (DNA) encodes Met and often starts ORFs." },
    { q: "Global alignment algorithm:", options: ["BLAST", "Smith–Waterman", "Needleman–Wunsch", "Burrows–Wheeler"], correct: 2, exp: "Needleman–Wunsch is for global; Smith–Waterman is local." },
    { q: "Format storing sequences with quality scores:", options: ["FASTA", "GFF3", "FASTQ", "PDB"], correct: 2, exp: "FASTQ stores sequence and per-base quality." },
    { q: "How many 3-mers in ATGCA?", options: ["2", "3", "4", "5"], correct: 1, exp: "n−k+1 = 5−3+1 = 3." },
    { q: "Common protein scoring matrix for general alignment:", options: ["BLOSUM30", "BLOSUM62", "PAM10", "PAM5"], correct: 1, exp: "BLOSUM62 is a widely used default." },
  ];

  const HARD = [
    { q: "Translate DNA ATGGCC (assume coding strand).", options: ["M-A", "W-A", "M-G", "G-M"], correct: 0, exp: "ATG→Met (M), GCC→Ala (A)." },
    { q: "Phred quality Q=30 implies error probability ~", options: ["0.1", "0.01", "0.001", "0.0001"], correct: 2, exp: "p ≈ 10^(−Q/10) → 10^-3 = 0.001." },
    { q: "Wallace rule Tm of primer ATGC (A,T,G,C counts = 1 each).", options: ["12 °C", "16 °C", "24 °C", "28 °C"], correct: 0, exp: "Tm≈2(A+T)+4(G+C). For ATGC: A+T=2, G+C=2 → 12 °C." },
    { q: "Which index compresses reference for fast read mapping?", options: ["Suffix array / FM-index", "Hash of kmers only", "Trie of all reads", "Bloom filter of genes"], correct: 0, exp: "FM-index over BWT enables fast substring queries." },
    { q: "Given 1% error rate, expected errors in 150 bp read:", options: ["0.15", "1.5", "15", "0.015"], correct: 1, exp: "150 × 0.01 = 1.5 expected errors." },
    { q: "Which alignment is local?", options: ["Needleman–Wunsch", "Smith–Waterman", "BLASTN only", "dot-plot"], correct: 1, exp: "Smith–Waterman is local alignment." },
    { q: "Which file holds genomic annotations?", options: ["BAM", "GFF3/GTF", "FASTQ", "SRA"], correct: 1, exp: "GFF3/GTF store genomic feature annotations." },
  ];

  // ---------- New problem-solving questions (MD, assembly, transcriptomics, metagenomics) ----------
  const PROBLEMS = [
    // MD simulation
    { q: "You ran a 10 ns MD production and see the RMSD continually increasing without plateau — which is the most likely cause?", options: ["Bad force field parameters", "System not equilibrated properly", "Insufficient visualization", "Too many water molecules"], correct: 1, exp: "If RMSD drifts, insufficient equilibration (minimization/slow heating/pressure equilibration) is often the cause." },
    { q: "You want to use a 2 fs timestep. Which condition is required for stability?", options: ["No constraints required", "Use constraints on bonds to hydrogen", "Use leapfrog integrator only", "Run in vacuum"], correct: 1, exp: "2 fs is common when bonds to H are constrained (e.g., SHAKE/LINCS)." },
    { q: "During an MD run total energy is not conserved in NVE—what's the best first diagnostic?", options: ["Check thermostat settings", "Check integrator timestep and constraints", "Increase system temperature", "Delete small molecules"], correct: 1, exp: "Non-conservation in NVE often indicates too-large timestep or constraint/integrator issues." },
    { q: "Your ligand dissociates immediately during equilibration — likely reason?", options: ["Ligand too small", "Missing restraint during equilibration or poor initial placement", "Protein has no secondary structure", "Simulation box too big"], correct: 1, exp: "Often you need positional restraints during equilibration or correct ligand placement; bad parameterization also possible." },

    // Genome assembly
    { q: "You assemble short reads and get many contigs with low N50. Coverage is 5×. What's the best next step?", options: ["Increase k-mer size", "Obtain more sequencing to increase coverage", "Remove adapters", "Use smaller assembler"], correct: 1, exp: "Low coverage (5×) leads to fragmented assemblies; additional sequencing to raise coverage helps." },
    { q: "You see many short contigs that are exact reverse complements of others — what's likely happened?", options: ["Assembler produced redundant contigs from both strands (unpolished)", "Sequencing produced palindromes", "Contamination with plasmids", "PCR duplicates only"], correct: 0, exp: "Assemblers may report both orientations or fail to collapse reverse complements; polishing/graph simplification is needed." },
    { q: "For a metagenome with uneven abundance, which assembler approach helps recover low-abundance genomes?", options: ["Single k-mer only", "Multi-k assembly or iterative assembly", "Skip error correction", "Use purely reference-based mapping"], correct: 1, exp: "Multi-k or iterative assemblies better capture both short and long repeats and low-abundance organisms." },

    // Transcriptomics
    { q: "You observe a gene with TPM 0 but many reads map to its locus in genome-guided alignment — likely issue?", options: ["TPM always counts reads so this is impossible", "Reads are multimapping and were discarded by quantifier", "Gene is not transcribed", "Library prep failed"], correct: 1, exp: "Quantifiers may discard or downweight multimapping reads, giving zero TPM even when reads map." },
    { q: "Designing differential expression: small sample (n=3 per group) but large variance — which is important to improve power?", options: ["Increase sequencing depth", "Increase biological replicates", "Remove batch correction", "Use TPM instead of counts"], correct: 1, exp: "Increasing biological replicates reduces variance and improves differential expression power more than extra depth." },
    { q: "Your DE pipeline shows many low-count genes significant. Best practice?", options: ["Remove genes with very low counts before testing", "Keep all genes", "Use TPM only", "Normalize by gene length only"], correct: 0, exp: "Filtering very low-count features reduces false positives and improves multiple-testing behavior." },

    // Metagenomics & taxonomy
    { q: "You used marker-based taxonomic profiler and find an unexpected marine species in a soil sample — first action?", options: ["Publish result", "Check for contamination in reagents and negative controls", "Assume horizontal gene transfer", "Increase classification confidence to 0.5"], correct: 1, exp: "Unexpected taxa often arise from contamination; check controls and reagent blanks first." },
    { q: "Shotgun metagenome alpha diversity decreases after removing short reads <100 bp — what explains this?", options: ["Short reads were errors/artifacts inflating diversity", "True diversity decreased", "Your sequencer failed", "Short reads always map to novel species"], correct: 0, exp: "Short, low-quality reads can create spurious OTUs/ASVs; filtering can reduce false diversity." },
    { q: "In taxonomic profiling, reads mapping equally well to two species are assigned to genus level — what is this method called?", options: ["Lowest Common Ancestor (LCA) assignment", "Best hit exclusive", "K-mer hashing", "Bayesian assembly"], correct: 0, exp: "LCA assigns ambiguous reads to the most specific common node (often genus/family)." },

    // Hybrid scenarios: assembly + transcriptomics
    { q: "You want to assemble a transcriptome de novo from RNA-seq but have both short (Illumina) and long (ONT) reads. Best strategy?", options: ["Assemble short reads only", "Use hybrid assembly or polish long-read assembly with short reads", "Discard long reads", "Map to a random genome"], correct: 1, exp: "Hybrid approaches use long reads for isoform structure and short reads to correct errors." },
    { q: "After assembling transcripts, you find many chimeric contigs. The likely cause and mitigation?", options: ["Cause: PCR artefacts or misassembly; Mitigation: stricter assembler parameters and read normalization", "Cause: too much memory; Mitigation: restart", "Cause: wrong primer; Mitigation: change chemistry", "Cause: host contamination; Mitigation: remove host reads"], correct: 0, exp: "Chimeras often come from PCR or assembly heuristics; filtering, normalization, or different assembler parameters help." },

    // Advanced MD + analysis
    { q: "You computed hydrogen-bond occupancy over trajectory and find 95% occupancy for a backbone H-bond. Interpretation?", options: ["Bond present in almost all frames (stable)", "Bond never exists", "Measurement error", "Only present in solvent"], correct: 0, exp: "High occupancy (~95%) indicates a stable hydrogen bond for most of the trajectory." },
    { q: "During clustering of MD frames you must pick an RMSD cutoff. If you pick too small a cutoff, result is:", options: ["Fewer clusters (more grouping)", "Many small clusters (fragmentation)", "No change", "Clusters will be reversed"], correct: 1, exp: "Too-small cutoffs produce many tiny clusters; choose cutoff to balance resolution and interpretability." },

    // Practical lab/computational troubleshooting
    { q: "An aligner reports very low mapping rates (<20%) for RNA-seq from human tissue. Which is a likely reason to check first?", options: ["Wrong reference genome (e.g., bacterial)", "You sequenced too deep", "You used single-end reads", "You used paired-end library"], correct: 0, exp: "Using the wrong reference (different species or transcriptome) leads to low mapping; check references and adapters." },
    { q: "You run a kraken2 classification and see many 'unclassified' reads — good step to reduce unclassified?", options: ["Lower confidence threshold", "Provide a more comprehensive database including expected organisms", "Remove quality filtering", "Trim adapters only"], correct: 1, exp: "Expanding the database to include more genomes increases chances of classification." },
  ];

  // Insert PROBLEMS across difficulty pools:
  // We'll add many to MED/HARD to increase problem-solving content.
  // Add roughly half to MED and half to HARD, preferring scenario-type to HARD.
  for (let i = 0; i < PROBLEMS.length; i++) {
    if (i % 2 === 0) MED.push(PROBLEMS[i]); else HARD.push(PROBLEMS[i]);
  }

  const LEVELS = [
    { name: "Level 1 — Warm-up", pool: EASY, timePerQ: 60, speed: 70 },
    { name: "Level 2 — Core", pool: MED, timePerQ: 45, speed: 90 },
    { name: "Level 3 — Problem-solving", pool: HARD, timePerQ: 30, speed: 110 },
  ];

  // ---------- Canvas + state (unchanged core game behavior) ----------
  const canvas = document.getElementById("game");
  const ctx = canvas.getContext("2d");
  let W = 0, H = 0, DPR = Math.max(1, window.devicePixelRatio || 1);

  function resize() {
    W = Math.floor(window.innerWidth);
    H = Math.floor(window.innerHeight);
    canvas.width = Math.floor(W * DPR);
    canvas.height = Math.floor(H * DPR);
    ctx.setTransform(DPR, 0, 0, DPR, 0, 0);
  }
  window.addEventListener("resize", resize, { passive: true });
  resize();

  // UI nodes
  const topbar = document.getElementById("topbar");
  const qbox = document.getElementById("qbox");
  const qtext = document.getElementById("qtext");
  const timefill = document.getElementById("timefill");
  const levelpill = document.getElementById("levelpill");
  const qindexEl = document.getElementById("qindex");
  const qtotalEl = document.getElementById("qtotal");
  const scoreEl = document.getElementById("score");
  const wrongEl = document.getElementById("wrong");
  const startscreen = document.getElementById("startscreen");
  const howpanel = document.getElementById("howpanel");
  const gameover = document.getElementById("gameover");
  const ovtitle = document.getElementById("ovtitle");
  const ovstats = document.getElementById("ovstats");
  const toast = document.getElementById("toast");
  const explain = document.getElementById("explain");

  document.getElementById("startbtn").onclick = startGame;
  document.getElementById("howbtn").onclick = () => {
    startscreen.style.display = "none";
    howpanel.style.display = "grid";
  };
  document.getElementById("howclose").onclick = () => {
    howpanel.style.display = "none";
    startscreen.style.display = "grid";
  };
  document.getElementById("restart").onclick = startGame;

  // ---------- Game entities ----------
  const rand = (a, b) => a + Math.random() * (b - a);
  const clamp = (v, a, b) => Math.max(a, Math.min(b, v));
  const dist2 = (ax, ay, bx, by) => {
    const dx = ax - bx, dy = ay - by;
    return dx*dx + dy*dy;
  };

  let mouse = { x: W/2, y: H-100 };
  window.addEventListener("mousemove", (e) => { mouse.x = e.clientX; mouse.y = e.clientY; }, { passive: true });

  // Touch to shoot toward tap
  window.addEventListener("touchstart", (e) => {
    const t = e.changedTouches[0];
    mouse.x = t.clientX; mouse.y = t.clientY;
    shoot();
    e.preventDefault();
  }, { passive: false });

  let bullets = [];
  let bubbles = [];
  let lastShot = 0;
  const SHOT_COOLDOWN = 250; // ms
  const BULLET_SPEED = 520; // px/s
  const BULLET_R = 5;

  let game = null;

  function newGame() {
    const levelStates = LEVELS.map((L) => ({
      meta: L,
      // Shuffle and take up to N questions (use all available if small)
      remaining: shuffle([...L.pool]),
    }));
    return {
      levelIndex: 0,
      qIndexWithinLevel: 0,
      score: 0,
      wrong: 0,
      state: "menu", // menu|playing|inter|over
      currentQ: null,
      timeLeft: 0,
      showExplainUntil: 0,
      levelStates,
      totalQuestions: LEVELS.reduce((n, L) => n + L.pool.length, 0),
      answered: 0,
    };
  }

  function shuffle(arr) {
    for (let i = arr.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [arr[i], arr[j]] = [arr[j], arr[i]];
    }
    return arr;
  }

  function startGame() {
    game = newGame();
    startscreen.style.display = "none";
    howpanel.style.display = "none";
    gameover.style.display = "none";
    toast.style.display = "block";
    topbar.style.display = "flex";
    qbox.style.display = "block";
    bullets = [];
    bubbles = [];
    game.state = "playing";
    nextQuestion();
  }

  function nextQuestion() {
    // Move to next level if needed
    while (game.levelIndex < game.levelStates.length && game.levelStates[game.levelIndex].remaining.length === 0) {
      game.levelIndex++;
      game.qIndexWithinLevel = 0;
    }
    if (game.levelIndex >= game.levelStates.length) {
      endGame();
      return;
    }
    const currentLevel = game.levelStates[game.levelIndex];
    // Pop a question
    game.currentQ = currentLevel.remaining.pop();
    game.timeLeft = currentLevel.meta.timePerQ;
    game.qIndexWithinLevel++;
    game.answered++;

    // UI updates
    levelpill.textContent = currentLevel.meta.name;
    qtext.textContent = game.currentQ.q;
    qindexEl.textContent = game.answered;
    qtotalEl.textContent = game.totalQuestions;
    scoreEl.textContent = game.score;
    wrongEl.textContent = game.wrong;
    updateTimerFill();

    // Create answer bubbles
    createBubblesForQuestion(game.currentQ, currentLevel.meta.speed);
  }

 function endGame() {
  game.state = "over";
  topbar.style.display = "none";
  qbox.style.display = "none";
  toast.style.display = "none";
  gameover.style.display = "grid";

  const totalAttempts = game.score + game.wrong;
  let accuracy = totalAttempts > 0 ? (game.score / totalAttempts) * 100 : 0;
  accuracy = Math.min(100, accuracy);

  ovtitle.textContent =
    accuracy >= 80 ? "Excellent!" :
    accuracy >= 50 ? "Nice run!" : "Keep practicing!";
  
  ovstats.textContent = `Score: ${game.score}/${game.totalQuestions} · Wrong: ${game.wrong} · Accuracy: ${accuracy.toFixed(1)}%`;
  }


  function createBubblesForQuestion(q, speed) {
    bubbles = [];
    const colors = ["#48c1c9", "#8a5cf6", "#f39c12", "#e74c3c", "#2ecc71", "#16a085"];
    const n = q.options.length;
    const R = Math.max(28, Math.min(56, Math.floor(Math.min(W, H) / 18)));
    for (let i = 0; i < n; i++) {
      // Spread around center area
      let x = rand(W * 0.15, W * 0.85);
      let y = rand(H * 0.25, H * 0.75);
      // Avoid overlapping too much
      let attempts = 0;
      while (attempts < 50 && bubbles.some(b => Math.hypot(b.x - x, b.y - y) < b.r + R + 20)) {
        x = rand(W * 0.15, W * 0.85);
        y = rand(H * 0.25, H * 0.75);
        attempts++;
      }
      const ang = rand(0, Math.PI * 2);
      const v = speed * rand(0.8, 1.2);
      bubbles.push({
        text: q.options[i],
        idx: i,
        isCorrect: i === q.correct,
        x, y,
        vx: Math.cos(ang) * v,
        vy: Math.sin(ang) * v,
        r: R,
        color: colors[i % colors.length],
      });
    }
  }

  function updateTimerFill() {
    const level = game.levelStates[game.levelIndex]?.meta;
    const total = level ? level.timePerQ : 1;
    const pct = clamp(game.timeLeft / total, 0, 1) * 100;
    timefill.style.width = `${pct}%`;
  }

  function shoot() {
    if (game?.state !== "playing") return;
    const now = performance.now();
    if (now - lastShot < SHOT_COOLDOWN) return;
    lastShot = now;

    const tx = clamp(mouse.x, 0, W);
    const ty = clamp(mouse.y, 0, H);
    const ox = W / 2, oy = H - 30; // turret origin
    const dx = tx - ox, dy = ty - oy;
    const len = Math.hypot(dx, dy) || 1;
    const ux = dx / len, uy = dy / len;
    bullets.push({
      x: ox + ux * 24,
      y: oy + uy * 24,
      vx: ux * BULLET_SPEED,
      vy: uy * BULLET_SPEED,
      r: BULLET_R,
      born: now,
    });
  }

  window.addEventListener("mousedown", shoot);
  window.addEventListener("keydown", (e) => {
    if (e.code === "Space") {
      e.preventDefault();
      shoot();
    }
  });

  // ---------- Game loop ----------
  let prev = performance.now();
  function loop(now) {
    const dt = Math.min(0.033, (now - prev) / 1000);
    prev = now;
    if (game && game.state === "playing") {
      game.timeLeft -= dt;
      if (game.timeLeft <= 0) {
        // Time up: count as wrong and advance
        game.wrong++;
        wrongEl.textContent = game.wrong;
        flashExplain(false, "Time's up!");
        setTimeout(nextQuestion, 900);
      }
      updateTimerFill();
    }
    update(dt);
    render(now);
    requestAnimationFrame(loop);
  }
  requestAnimationFrame(loop);

  function update(dt) {
    // Move bubbles
    for (const b of bubbles) {
      b.x += b.vx * dt;
      b.y += b.vy * dt;
      // Bounce
      if (b.x < b.r && b.vx < 0) { b.x = b.r; b.vx *= -1; }
      if (b.x > W - b.r && b.vx > 0) { b.x = W - b.r; b.vx *= -1; }
      if (b.y < b.r + 120 && b.vy < 0) { b.y = b.r + 120; b.vy *= -1; } // keep below question UI
      if (b.y > H - b.r - 40 && b.vy > 0) { b.y = H - b.r - 40; b.vy *= -1; }

      // Mild drift variation
      b.vx += rand(-10, 10) * dt;
      b.vy += rand(-10, 10) * dt;
      const v = Math.hypot(b.vx, b.vy);
      const max = (game?.levelStates[game?.levelIndex]?.meta?.speed || 90) * 1.4;
      if (v > max) { b.vx *= max / v; b.vy *= max / v; }
    }

    // Move bullets
    const bulletsNew = [];
    for (const p of bullets) {
      p.x += p.vx * dt;
      p.y += p.vy * dt;
      if (p.x < -20 || p.x > W + 20 || p.y < -20 || p.y > H + 20) continue;
      bulletsNew.push(p);
    }
    bullets = bulletsNew;

    // Collisions bullets vs bubbles
    if (game && game.state === "playing") {
      outer:
      for (let i = bullets.length - 1; i >= 0; i--) {
        const p = bullets[i];
        for (let j = bubbles.length - 1; j >= 0; j--) {
          const b = bubbles[j];
          const rr = (p.r + b.r) * (p.r + b.r);
          if (dist2(p.x, p.y, b.x, b.y) <= rr) {
            // Hit
            bullets.splice(i, 1);
            handleHit(b);
            break outer;
          }
        }
      }
    }
  }

  function handleHit(b) {
    if (!game || game.state !== "playing") return;
    if (b.isCorrect) {
      game.score++;
      scoreEl.textContent = game.score;
      flashExplain(true, "Correct! " + (game.currentQ.exp || ""));
      setTimeout(nextQuestion, 700);
    } else {
      game.wrong++;
      wrongEl.textContent = game.wrong;
      // Time penalty
      const penalty = Math.max(2, Math.min(8, Math.round(game.timeLeft * 0.15)));
      game.timeLeft = Math.max(0, game.timeLeft - penalty);
      screenShake();
      flashExplain(false, `Wrong. −${penalty}s`);
    }
  }

  // ---------- Effects ----------
  let shakeT = 0, shakeMag = 0;
  function screenShake() {
    shakeT = 180; // ms
    shakeMag = 6;
  }

  function flashExplain(ok, msg) {
    explain.textContent = msg;
    explain.style.display = "block";
    explain.style.color = ok ? "var(--good)" : "var(--bad)";
    clearTimeout(flashExplain._t);
    flashExplain._t = setTimeout(() => { explain.style.display = "none"; }, 1200);
  }

  // ---------- Render ----------
  function render(now) {
    // Background with gentle gradient dots
    ctx.clearRect(0, 0, W, H);
    const bgGrad = ctx.createLinearGradient(0, 0, 0, H);
    bgGrad.addColorStop(0, "#e9ecf2");
    bgGrad.addColorStop(1, "#486096");
    ctx.fillStyle = bgGrad;
    ctx.fillRect(0, 0, W, H);

    // Optional screen shake
    if (shakeT > 0) {
      const t = Math.min(1, shakeT / 180);
      const dx = (Math.random() * 2 - 1) * shakeMag * t;
      const dy = (Math.random() * 2 - 1) * shakeMag * t;
      ctx.save();
      ctx.translate(dx, dy);
      drawScene();
      ctx.restore();
      shakeT -= 16;
    } else {
      drawScene();
    }

    // UI
    if (game && game.state === "playing") {
      topbar.style.display = "flex";
      qbox.style.display = "block";
    }
  }

  function drawScene() {
    // Draw bubbles
    for (const b of bubbles) {
      drawBubble(b);
    }

    // Draw bullets
    for (const p of bullets) {
      ctx.beginPath();
      ctx.fillStyle = "#ffffff";
      ctx.arc(p.x, p.y, p.r, 0, Math.PI * 2);
      ctx.fill();
    }

    // Draw turret
    drawTurret();
  }

  function drawBubble(b) {
    // Body
    ctx.beginPath();
    const grad = ctx.createRadialGradient(b.x - b.r * 0.4, b.y - b.r * 0.5, b.r * 0.2, b.x, b.y, b.r);
    grad.addColorStop(0, lighten(b.color, 0.25));
    grad.addColorStop(1, b.color);
    ctx.fillStyle = grad;
    ctx.arc(b.x, b.y, b.r, 0, Math.PI * 2);
    ctx.fill();

    // Outline
    ctx.strokeStyle = "rgba(255,255,255,0.4)";
    ctx.lineWidth = 2;
    ctx.stroke();

    // Text
    const maxWidth = b.r * 1.6;
    ctx.fillStyle = "#0b1221";
    ctx.font = `700 ${Math.max(12, Math.min(18, b.r * 0.45))}px ui-sans-serif, system-ui, Segoe UI`;
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    wrapText(b.text, b.x, b.y, maxWidth, Math.max(14, b.r * 0.5));
  }

  function drawTurret() {
    const ox = W / 2, oy = H - 50;
    // Base
    ctx.fillStyle = "#172038";
    roundRect(ctx, ox - 60, oy, 120, 30, 12);
    ctx.fill();

    // Aim
    const dx = mouse.x - ox, dy = mouse.y - oy;
    const ang = Math.atan2(dy, dx);
    const len = 50;
    ctx.save();
    ctx.translate(ox, oy);
    ctx.rotate(ang);
    roundRect(ctx, -10, -14, len, 20, 8);
    ctx.fillStyle = "#2b8ef6";
    ctx.fill();
    ctx.restore();

    // Crosshair
    ctx.beginPath();
    ctx.strokeStyle = "rgba(255,255,255,0.25)";
    ctx.lineWidth = 1;
    ctx.arc(mouse.x, mouse.y, 12, 0, Math.PI * 2);
    ctx.moveTo(mouse.x - 16, mouse.y); ctx.lineTo(mouse.x + 16, mouse.y);
    ctx.moveTo(mouse.x, mouse.y - 16); ctx.lineTo(mouse.x, mouse.y + 16);
    ctx.stroke();
  }

  function roundRect(ctx, x, y, w, h, r) {
    const rr = Math.min(r, w/2, h/2);
    ctx.beginPath();
    ctx.moveTo(x+rr, y);
    ctx.arcTo(x+w, y, x+w, y+h, rr);
    ctx.arcTo(x+w, y+h, x, y+h, rr);
    ctx.arcTo(x, y+h, x, y, rr);
    ctx.arcTo(x, y, x+w, y, rr);
    ctx.closePath();
  }

  function wrapText(text, x, y, maxWidth, lineHeight) {
    const words = text.split(" ");
    let line = "";
    const lines = [];
    for (let n = 0; n < words.length; n++) {
      const test = line + (line ? " " : "") + words[n];
      const m = ctx.measureText(test);
      if (m.width > maxWidth && n > 0) {
        lines.push(line);
        line = words[n];
      } else {
        line = test;
      }
    }
    lines.push(line);
    // Center vertically
    const totalH = lines.length * lineHeight * 0.8;
    let yy = y - totalH / 2 + lineHeight * 0.4;
    for (const ln of lines) {
      ctx.fillText(ln, x, yy);
      yy += lineHeight * 0.8;
    }
  }

  function lighten(hex, amt) {
    const c = parseInt(hex.slice(1), 16);
    let r = (c >> 16) & 255, g = (c >> 8) & 255, b = c & 255;
    r = Math.min(255, Math.floor(r + (255 - r) * amt));
    g = Math.min(255, Math.floor(g + (255 - g) * amt));
    b = Math.min(255, Math.floor(b + (255 - b) * amt));
    return "#" + ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1);
  }

  // ---------- Accessibility helpers ----------
  // Keyboard: left/right to nudge aim, Enter to shoot
  window.addEventListener("keydown", (e) => {
    if (!game || game.state !== "playing") return;
    if (e.code === "ArrowLeft") { mouse.x = Math.max(0, mouse.x - 20); }
    if (e.code === "ArrowRight") { mouse.x = Math.min(W, mouse.x + 20); }
    if (e.code === "ArrowUp") { mouse.y = Math.max(0, mouse.y - 20); }
    if (e.code === "ArrowDown") { mouse.y = Math.min(H, mouse.y + 20); }
    if (e.code === "Enter") { shoot(); }
  });

})();
</script>
</body>
</html>
